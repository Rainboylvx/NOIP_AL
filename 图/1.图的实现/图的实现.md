

## 一些基本说明

我们常用到的量

```
int n,m;            //n代表点数,m代表边数
int G[N][N];
int u[M],v[M],w[M];
int first[N],next[M];
vector<int> g[N];
edge *adj[N];
const int INF = 0x7fffffff/3;
```

## 图的实现

### 1.邻接矩阵

二维数组`G[N][N]`

其中如果  边`<i,j>`不存在,`G[i][j] = INF`,当然`G[i][i] = INF`



### 2. 邻接表(动态化静态)


### 3.边集数组

```
int first[N];
int u[M],v[M],w[M],next[M];

memset(first,-1,sizeof(first));
for(e=1;e<=m;e++){
    scanf("%d%d%d",&u[e],&v[e],&w[e]);
    next[e] = first[u[e]];
    first[u[e]] = e;
}
```

访问所有点a的相临点
```
int e;
for(e=first[a];e!=-1;e=next[e]){
    //TODO 
    //v[e] ,a的相临点
}
```

### 邻接表 -STL实现

```
vector<int> g[n];
int e;
int u[M],v[M],w[M];

for(e=1;e<=m;e++){
    scanf("%d%d%d",&u[e],&v[e],&w[e]);
    g[ u[e] ].push_back(e);
}

```

想找出点a的相临点

```
int i;
for(i=0;i<=g[a].size();i++){
    int &e = g[a][i]; //得到哪一条边
    //u[e]起点,v[e]是终点,w[e]权
}
```
