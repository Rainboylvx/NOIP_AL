


## 二分图

简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、VV中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图


二分图的条件:图G至少有二个点,且所有的回路边数为偶数




**匹配**给定一个二分图G,M是G边集的一个子集,如果M中边都满足:**当中的任意两条边都没有公共顶点**,则称M是一个匹配.

**最大匹配**：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。

**完美匹配**：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。


**增广路**:如果一条路径的首尾是非匹配点，路径中除此之外（如果有）其他的点均是匹配点，那么这条路径就是一条增广路径（Agumenting path）


增广路径的首尾是非匹配点。因此，增广路径的第一条和最后一条边，必然是非匹配边；同时它的第二条边（如果有）和倒数第二条边（如果有），必然是匹配边；以及第三条边（如果有）和倒数第三条边（如果有），一定是非匹配边。

亦即，增广路径从非匹配边开始，匹配边和非匹配边依次交替，最后由非匹配边结束。这样一来，增广路径中非匹配边的数目会比匹配边大 1。

## 匈牙利算法

匈牙利算法的目的是为了找到二分图的最大匹配,使用的方法是不停的寻找图的增广路,如果找到一条增广路,把增广路取反,匹配的数量就加1,直到找不到增广路为止.有DFS和BFS版,其中BFS的效率较高


由上面我们可以知道,算法的核心是寻找增广路,那如果寻找呢?这里说一下DFS的算法.

 - 增广路一定是由没有匹配的点开始的,所以我先找到一个未匹配点A
 - 寻找点A相邻的点B,如果B是未匹配点,那你就找到了一个新的匹配,返回即可
 - 如果B是一个匹配点,那我们就从B的相对应的匹配点C开始DFS
   - `A->B->C`这条路径中,`A->B`是未匹配边,`B->C`是匹配边
 - 从C开始不停的重复上面的动作,直到找到一个点X不是匹配点
   - 也就找到了一条增广路,取反后,匹配数+1

所以我们不停的找增广路,直到找不到增广路为止,那也就找到了最大匹配,这是一个贪心算法.

只要把一边的点遍历一遍即可,因为如果从一个点A找到增广路或者匹配,那以后也就找到了.











定义：在一个有向图中，找出最少的路径，使得这些路径，经过每一个点，且每一个点只与一条路径相关联，

由上面得出：

1.一个单独的点是一个路径


 对于一个 有向无环图 怎么求最小路径覆盖？

先构造二分图： 对于原图，先拆点，吧每个点i拆成ii，iii。若有边i--》j,则在二分图中，添加边 ii--》jjj（即原来每个点拆为一个入点和出点)，这样构成二分图。

则：最小路径覆盖数=原图顶点数-二分图最大匹配数。

粗略解析证明：（设有n个顶点）

若原图没有边，则最大匹配数为0，最小路径覆盖为n，思想：每得到一个匹配，相当于把这俩个点并为一个集合（原来有N个集合），即这俩个点在原图中是在同一条路径覆盖上的，每次成功匹配，相当于一次成功“并集”，所谓的路径覆盖，可以理解为合并顶点的动作，而匹配的点不重复（分出俩个点恰好对应路径覆盖时该店的一出一入），每成功一次匹配，则顶点集合少了一，即路径少了一条，所以最小路径覆盖对应最大匹配的时候,即证。 


## 引用地址

http://blog.csdn.net/xuguangsoft/article/details/7861988

http://www.renfei.org/blog/bipartite-matching.html
