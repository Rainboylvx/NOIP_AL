
### 如何证明TarjanDFS是对的?

https://www.byvoid.com/blog/scc-tarjan/
http://www.cnblogs.com/saltless/archive/2010/11/08/1871430.html

1. low() 一个操作一定是对的

在DFS中,同一强连通分量内的所有顶点都在同一棵深度优先树搜索树中,也就是说强连通分量一定是DFS树的子树

这个子树的元素在栈中一定是相临的,且root在子树所有元素的下面
dfn用来记录

强连通分量是由若干个环组成的。所以，当有环形成时（也就是搜索的下一个点已在栈中），我们将这一条路径的low值统一，即这条路径上的点属于同一个强连通分量。

如果dfn=low,那这个点一定是root,输出


按我们的定义,DFS子树上的low 值应该一样,这是一种理解状态,但是算法的过程中,应该能实际达到一样.

猜想:当点i low[i]=dfn[i] 时 i为root点,输出 stack.top -> stack.i的元素,

如果一个点i已经 遍历完它的所有相临点,有如果有一个点j,且点`dfn[j] < dfn[i]`那low[i] 一定会变得比dfn[i] 小(但是不是理论值,dfn[root])

low[i] 应该是代表i相连的最早的点

/-------------------/
DFS 中一个强连通分量 里的点 可以相互访问,所以一定在一棵DFS树中,又因为一个DFS树可能有多个强连通分量,所以一定是DFS对的子树

DFS在


验证 
根据我们自己构造的数据,确实是这这样的,
