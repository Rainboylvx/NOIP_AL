---
title: A*算法
date:  2016-04-11 09:44
categories:
    - NOIP
tags:
    - 搜索
---

## 抽象的过程

```
    把起始格添加到开启列表。
    重复如下的工作：
        寻找开启列表中F值最低的格子。我们称它为当前格。
        把它切换到关闭列表。
        对相邻的格中的每一个？
            如果它不可通过或者已经在关闭列表中，略过它。反之如下。
            如果它不在开启列表中，把它添加进去。把当前格作为这一格的父节点。记录这一格的F,G,和H值。
            如果它已经在开启列表中，用G值为参考检查新的路径是否更好。更低的G值意味着更好的路径。如果是这样，就把这一格的父节点改成当前格，并且重新计算这一格的G和F值。如果你保持你的开启列表按F值排序，改变之后你可能需要重新对开启列表排序。
        停止，当你
            把目标格添加进了关闭列表，这时候路径被找到，或者
            没有找到目标格，开启列表已经空了。这时候，路径不存在。
    保存路径。从目标格开始，沿着每一格的父节点移动直到回到起始格。这就是你的路径。

```

```
open_list
close_list

把起点 加入 [open_list]
do{
    寻找[open_list]中F值最小的格子,A
    把A加入到[close_list]中
    对A格子中相邻格子中的每一个 :
        if(它不可通过 ||已经在[close_list]中){
            什么也不做;
        }
        if(它不在[open_list]中){
            把它添加进[open_list]中,把A作为这一格的父节点,计算这一格的FGH
        }
        if(它已经在[open_list]中){
            if(G值能被更新){
                把这一格的父节点改成A,并重新计算这一格的GF值
            }
        }
}while(终点不在[open_list中] || open_list 不为空)

如果open_list 为空了也没有找到终点,那就是说明路径不存在
```


## 参考

 1. http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html
 2. http://blog.csdn.net/b2b160/article/details/4057781


