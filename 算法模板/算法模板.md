
<p style="text-align: center;font-size:50px">算法模板</p>
<p style="text-align: right;font-size:24px">BY Rainboy</p>

[TOC]

# 说明

`★`表示应该熟练掌握,能夠非常快速的写出代码,背下来

`☆`表示代码整理程度不完整,存在缺陷

`✡`表示超越NOIP难度


## 排序算法

### 冒泡排序

```
int a[10]= {0,3,2,4,9,1,5,7,6,8};
for(i=1;i<=n-1;i++)
    for(j=1;j<=n-i;j++)
        if(a[j] > a[j+1])   tmp =a[j],a[j] =a[j+1],a[j+1]=tmp;
```

### 归并排序

```
int a[] ={1,7,3,6,5,2};
int tmp[100]; //临时存储的中间数组

void merge_sort(int s,int t){
    int mid,i,j,k;
    if(s==t) return ; //如果区间只有一个数,就返回
    mid = (s+t)>>1; //取中间的点
    merge_sort(s,mid);
    merge_sort(mid+1,t);

    i=s;
    j=mid+1;
    k=s;

    while(i<=mid && j<=t){
        if( a[i] <=a[j]){
            tmp[k]=a[i];k++;i++;
        } else {
            tmp[k]=a[j];j++;k++;
        }
    }

    while(i<=mid) { tmp[k]=a[i];k++;i++;};
    while(j<=t)   { tmp[k]=a[j];k++;j++;};

    for(i=s;i<=t;i++)
        a[i]=tmp[i];
}
```

归并排序可以求逆对:**火柴棒排序**

### ★快速排序

```
int a[]={6,2,7,3,8,9};
void quicksort(int l,int r){
    int s=l,t=r;
    int key =a[l]; // 取第一个值为key
    while(s < t){
        while( s <t && a[t] >= key) --t;// 如果a[t] >= key,t下标不停变小,直到a[t] < key
        if(s < t) a[s++] = a[t];        //停下来的时候,看一看,是不是到中点,如果不是 交换值
        while(s<t && a[s] <= key) ++s;  //如果a[s] <= key  s的下标不停变大,直到a[s] > key
        if(s<t ) a[t--] = a[s];         //停下来的时候,看一看,是不是到了中点,如果不是,交换值
    }
    a[s] = key;                         //上面while停止的时候,一定是s ==t
    quicksort(l,s-1);
    quicksort(s+1,r);
}
```

## 数论

gcd

ex_gcd


## 高精度

## 贪心

## 搜索

## 分治

## 树

## 图论


## 高级数据结构

## STL


